# FastAPI WebSocket Integration Guide

## Overview
This guide explains how to implement WebSocket functionality in the FastAPI server for real-time updates in BugZapp.

## Server-Side Implementation

1. WebSocket Connection Manager
```python
from fastapi import WebSocket
from typing import Dict, List

class ConnectionManager:
    def __init__(self):
        self.active_connections: Dict[int, List[WebSocket]] = {}

    async def connect(self, websocket: WebSocket, user_id: int):
        await websocket.accept()
        if user_id not in self.active_connections:
            self.active_connections[user_id] = []
        self.active_connections[user_id].append(websocket)

    async def disconnect(self, websocket: WebSocket, user_id: int):
        if user_id in self.active_connections:
            self.active_connections[user_id].remove(websocket)
            if not self.active_connections[user_id]:
                del self.active_connections[user_id]

    async def broadcast_to_user(self, user_id: int, message: dict):
        if user_id in self.active_connections:
            for connection in self.active_connections[user_id]:
                try:
                    await connection.send_json(message)
                except Exception as e:
                    print(f"Error sending message to user {user_id}: {e}")

    async def broadcast_to_all(self, message: dict):
        for connections in self.active_connections.values():
            for connection in connections:
                try:
                    await connection.send_json(message)
                except Exception as e:
                    print(f"Error broadcasting message: {e}")
```

2. WebSocket Route Handler
```python
from fastapi import FastAPI, WebSocket, WebSocketDisconnect, Depends
from app.auth.jwt import get_current_user_from_token

app = FastAPI()
manager = ConnectionManager()

@app.websocket("/ws")
async def websocket_endpoint(
    websocket: WebSocket,
    token: str = Depends(get_current_user_from_token)
):
    user_id = token.get("sub")
    try:
        await manager.connect(websocket, user_id)
        while True:
            try:
                # Wait for messages from the client
                data = await websocket.receive_json()
                # Handle client messages if needed
            except WebSocketDisconnect:
                await manager.disconnect(websocket, user_id)
                break
            except Exception as e:
                print(f"Error in WebSocket connection: {e}")
                break
    finally:
        await manager.disconnect(websocket, user_id)
```

3. Event Broadcasting Functions
```python
async def broadcast_bug_report_update(bug_report: dict, event_type: str):
    message = {
        "type": "bug_report",
        "action": event_type,
        "payload": bug_report
    }
    await manager.broadcast_to_all(message)

async def broadcast_comment_update(comment: dict, event_type: str):
    message = {
        "type": "comment",
        "action": event_type,
        "payload": comment
    }
    await manager.broadcast_to_all(message)

async def send_user_notification(user_id: int, notification: dict):
    message = {
        "type": "notification",
        "payload": notification
    }
    await manager.broadcast_to_user(user_id, message)
```

4. Integration with Routes
```python
@app.post("/bug-reports/")
async def create_bug_report(bug_report: BugReportCreate):
    # Create bug report in database
    new_bug_report = await crud.create_bug_report(bug_report)
    
    # Broadcast update to all connected clients
    await broadcast_bug_report_update(
        new_bug_report.dict(),
        "created"
    )
    
    # Send notification to assigned user
    if new_bug_report.assignee_id:
        notification = {
            "message": f"New bug report assigned: {new_bug_report.title}",
            "bug_report_id": new_bug_report.id
        }
        await send_user_notification(
            new_bug_report.assignee_id,
            notification
        )
    
    return new_bug_report
```

## Client-Side Integration

1. WebSocket Connection Setup
```dart
class WebSocketService {
  final String baseUrl;
  final AuthService authService;
  WebSocketChannel? _channel;
  
  Future<void> connect() async {
    final token = await authService.getToken();
    if (token == null) return;
    
    final wsUrl = Uri.parse('$baseUrl/ws?token=$token');
    _channel = WebSocketChannel.connect(wsUrl);
    
    _channel?.stream.listen(
      (message) => _handleMessage(jsonDecode(message)),
      onError: (error) => _handleError(error),
      onDone: () => _handleDisconnect(),
    );
  }
  
  void _handleMessage(Map<String, dynamic> data) {
    final type = data['type'];
    final action = data['action'];
    final payload = data['payload'];
    
    switch (type) {
      case 'bug_report':
        _handleBugReportUpdate(action, payload);
        break;
      case 'comment':
        _handleCommentUpdate(action, payload);
        break;
      case 'notification':
        _handleNotification(payload);
        break;
    }
  }
}
```

2. Event Handling in UI
```dart
class HomeScreen extends StatefulWidget {
  @override
  _HomeScreenState createState() => _HomeScreenState();
}

class _HomeScreenState extends State<HomeScreen> {
  late WebSocketService _webSocketService;
  late StreamSubscription _bugReportSubscription;
  
  @override
  void initState() {
    super.initState();
    _webSocketService = WebSocketService();
    _webSocketService.connect();
    
    _bugReportSubscription = _webSocketService
        .bugReportStream
        .listen((bugReport) {
          setState(() {
            // Update UI with new bug report data
          });
        });
  }
  
  @override
  void dispose() {
    _bugReportSubscription.cancel();
    _webSocketService.dispose();
    super.dispose();
  }
}
```

## Error Handling and Recovery

1. Connection Error Handling
```python
@app.websocket("/ws")
async def websocket_endpoint(websocket: WebSocket):
    try:
        await websocket.accept()
    except Exception as e:
        print(f"Failed to accept WebSocket connection: {e}")
        return
    
    try:
        while True:
            try:
                data = await websocket.receive_json()
                # Process message
            except WebSocketDisconnect:
                break
            except ValueError as e:
                # Handle invalid JSON
                await websocket.send_json({
                    "type": "error",
                    "payload": {"message": "Invalid message format"}
                })
            except Exception as e:
                print(f"Error processing message: {e}")
                break
    finally:
        await manager.disconnect(websocket)
```

2. Client-Side Error Recovery
```dart
class WebSocketService {
  int _reconnectAttempts = 0;
  static const int maxReconnectAttempts = 5;
  
  Future<void> _reconnect() async {
    if (_reconnectAttempts >= maxReconnectAttempts) {
      print('Max reconnection attempts reached');
      return;
    }
    
    final delay = Duration(seconds: pow(2, _reconnectAttempts).toInt());
    _reconnectAttempts++;
    
    await Future.delayed(delay);
    connect();
  }
  
  void _handleError(error) {
    print('WebSocket error: $error');
    _reconnect();
  }
  
  void _handleDisconnect() {
    print('WebSocket disconnected');
    _reconnect();
  }
}
```

## Security Considerations

1. Authentication Middleware
```python
from fastapi import WebSocket, HTTPException
from app.auth.jwt import decode_token

async def get_current_user_ws(
    websocket: WebSocket,
    token: str = Query(None)
):
    if token is None:
        raise HTTPException(status_code=403, detail="Not authenticated")
    
    try:
        payload = decode_token(token)
        return payload
    except Exception as e:
        raise HTTPException(
            status_code=403,
            detail="Invalid authentication token"
        )

@app.websocket("/ws")
async def websocket_endpoint(
    websocket: WebSocket,
    user: dict = Depends(get_current_user_ws)
):
    # Handle WebSocket connection
```

2. Rate Limiting
```python
from fastapi import WebSocket
from datetime import datetime, timedelta

class RateLimiter:
    def __init__(self, max_messages: int, window_seconds: int):
        self.max_messages = max_messages
        self.window_seconds = window_seconds
        self.messages = {}
    
    async def check_rate_limit(
        self,
        websocket: WebSocket,
        user_id: int
    ) -> bool:
        now = datetime.now()
        window_start = now - timedelta(seconds=self.window_seconds)
        
        if user_id not in self.messages:
            self.messages[user_id] = []
        
        # Remove old messages
        self.messages[user_id] = [
            ts for ts in self.messages[user_id]
            if ts > window_start
        ]
        
        if len(self.messages[user_id]) >= self.max_messages:
            await websocket.send_json({
                "type": "error",
                "payload": {"message": "Rate limit exceeded"}
            })
            return False
        
        self.messages[user_id].append(now)
        return True
```

## Testing

1. WebSocket Test Client
```python
from fastapi.testclient import TestClient
import pytest

@pytest.fixture
def websocket_client():
    token = create_test_token()
    with TestClient(app).websocket_connect(
        f"/ws?token={token}"
    ) as websocket:
        yield websocket

def test_websocket_connection(websocket_client):
    data = websocket_client.receive_json()
    assert data["type"] == "connection_established"

def test_bug_report_update(websocket_client):
    # Create a bug report
    bug_report = create_test_bug_report()
    
    # Receive WebSocket message
    data = websocket_client.receive_json()
    assert data["type"] == "bug_report"
    assert data["action"] == "created"
    assert data["payload"]["id"] == bug_report.id
```

## Monitoring and Logging

1. Connection Monitoring
```python
from prometheus_client import Counter, Gauge

ws_connections = Gauge(
    'websocket_active_connections',
    'Number of active WebSocket connections'
)

ws_messages = Counter(
    'websocket_messages_total',
    'Total WebSocket messages handled',
    ['type']
)

class ConnectionManager:
    async def connect(self, websocket: WebSocket, user_id: int):
        await websocket.accept()
        self.active_connections[user_id].append(websocket)
        ws_connections.inc()
    
    async def disconnect(self, websocket: WebSocket, user_id: int):
        self.active_connections[user_id].remove(websocket)
        ws_connections.dec()
    
    async def broadcast_message(self, message: dict):
        ws_messages.labels(type=message["type"]).inc()
        # Broadcast message
```

2. Error Logging
```python
import logging

logger = logging.getLogger(__name__)

@app.websocket("/ws")
async def websocket_endpoint(websocket: WebSocket):
    try:
        await websocket.accept()
        logger.info("New WebSocket connection established")
    except Exception as e:
        logger.error(f"Failed to accept WebSocket connection: {e}")
        return
    
    try:
        while True:
            try:
                data = await websocket.receive_json()
                logger.debug(f"Received WebSocket message: {data}")
            except WebSocketDisconnect:
                logger.info("WebSocket connection closed by client")
                break
            except Exception as e:
                logger.error(f"Error processing WebSocket message: {e}")
                break
    finally:
        logger.info("WebSocket connection closed")
```

## Deployment Considerations

1. Load Balancing
- Use sticky sessions for WebSocket connections
- Configure timeout settings appropriately
- Monitor connection distribution

2. Scaling
- Implement message queue for broadcast operations
- Use Redis for connection management in multi-instance setup
- Monitor resource usage

3. Failover
- Implement graceful connection handling
- Store connection state for recovery
- Monitor service health 